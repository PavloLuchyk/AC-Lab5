 TITLE lab5
;----------------I.ЗАГОЛОВОК ПРОГРАМИ------------------------
IDEAL
MODEL SMALL
STACK 16384
;-----------------------II.МАКРОСИ--------------------------------------
; Складний макрос для ініціалізації
MACRO M_Init        ; Початок макросу 
    mov ax,@data    ; @data ідентифікатор, що створюються директивою model
    mov ds, ax  ; Завантаження початку сегменту даних в регістр ds
    mov es, ax  ; Завантаження початку сегменту даних в регістр es
ENDM M_Init     

;--------------------III.ПОЧАТОК СЕГМЕНТУ ДАНИХ--------------
DATASEG

;Оголошення двовимірного масиву 16х16
arr_stack        DW  '5', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6'
                DW  '5', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6'
                DW  '5', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6'
                DW  '5', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6'
                DW  '2', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6'
                DW  '2', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6'
                DW  '2', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6'
                DW  '2', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6'
                DW  '2', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6'
                DW  '2', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6'
                DW  '5', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6'
                Dw  '5', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6'
                DW  '5', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6'
                DW  '5', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6'
                DW  '5', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6'
                DW  '5', '6', '4', '3', '2', '1', '0', '5', '6', '0', '2', '4', '1', '0', '8', '6',13, 10,'$'

exCode  DB 0
dateP dw '2','5','1','1','2','0','0','1'
dateD dw '1','2','0','6','2','0','0','2'
dateS dw '1','2','0','2','2','0','0','2'


;----------------------VI. ПОЧАТОК СЕГМЕНТУ КОДУ-------------------
Codeseg
Start: 
M_Init
call sort  ; сортуємо масив
xor si,si
lea ax,[arr_stack]   ; записуємо в регістр початок масиву
mov dx,ax
mov ah, 09h
int 21h             ; виводимо відсортований масив
mov ah,01h
int 21h             ; чекаємо на введення клавіші
lea si,[arr_stack]
add si,120h             ; переміщуємось на координати (5,5)
mov cx,2            
add_to_array:           ; вставляємо прямокутник з датами 8х6
    lea di,[dateP]   ; записуємо в регістр початок сегменту памяті дат
    push cx             ; запамятовуємо кількість ітерацій
    call add_date        ; записуємо 1 дату
    add si,10h              ; переміщуємось на рядок
    call add_date           ; записуємо 2 дату
    add si,10h
    call add_date           ; записуємо 3 дату
    pop cx                  ; повертаємо в регістр кількість ітерцій, що залишилися
    add si,10h
loop add_to_array


lea di,[dateP]       ; додаємо до прямокутника 8х6 ще 2 дати
call add_date
add si,10h
call add_date

mov ah, 09h             ; виводимо масив з датами
int 21h
mov ah,01h
int 21h

mov ah,4ch              ;завершення програми
mov al,[exCode]
int 21h 
;---------------------Процедури-----------------------------------------
proc sort
mov bp,256  ; записуємо кількість ітерацій зовнішнього циклу
C:
    mov cx, 256 ; записуємо кількість ітерацій внутрішньго циклу
    dec cx      ; зменшуємо на одиницю кільксть ітерцій внутрішнього циклу
    lea bx, [arr_stack] ; записуємо у регістр початок сегменту памяті, де зберігається масив
    mov si, 510             ; переходимо в кінець масиву
B:
    mov ax, [bx + si]  ; записуємо в регістр останній елемент масиву
    mov di, si
    A:  
        sub di, 2           
        mov dx, [bx + di]       ; переходиом до наступного елементу(рахуючи з кінця)
 
        cmp ax, dx              ; порівняння цих 2 елементів
        jng next                 ; якщо преший елемент не більший, пропускаємо наступні 2 кроки
            mov [bx+di], ax     ; міняємо місцями 2 елементи
            mov [bx+si], dx
     next:
     sub si, 2                  ; переходимо да наступного елементу
     loop B
        xor si, si             ; анулюємо індексні регістри щоб прейти до наступного кроку
         xor di, di
         dec bp                ; позначаємо, що ітерацію завершено
         cmp bp,0               ; порівнюємо кількість операцій з 0
         jne c                  ; поки кільксть ітерацій не буде рівним нулю, повторюєм цикл
 
 
ret
endp sort
   
proc add_date
mov cx,8                ; задаємо кількість ітерацій
D:
mov ax,[ds:di]              ; записуємо в регістр цифру з дати
mov [ds:si],ax              ; записуємо цю цифру в масив
add si,2                    ; преходимо до наступної цифри
add di,2
loop D
ret
endp add_date
 
end Start